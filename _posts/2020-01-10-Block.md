---
layout:     post
title:      "Block的疑难杂症"
subtitle:   " \"关于使用的一些Block相关汇总\""
date:       2020-01-10 12:00:00
author:     "jsw_cool"
header-img: "img/post-bg-infinity.jpg"
catalog: true
tags:
    - iOS
---



一、首先，我们准备一个.m文件。我这里是main.m。内容如下:
```
int main(int argc, char * argv[]) {
    void (^test)() = ^(){
    };
    test();
}
```
接下来我要用到一个命令clang src.m -rewrite-objc -o dest.cpp
```
//__block_imp：  这个是编译器给我们生成的结构体，每一个block都会用到这个结构体
struct __block_impl {
  void *isa;　　　　　　　　　//对于本文可以忽略
  int Flags;　　　　　　　　  //对于本文可以忽略
  int Reserved;　　　　　　　//对于本文可以忽略　　　　　　　
  void *FuncPtr;　　　　　　 //函数指针，这个会指向编译器给我们生成的下面的静态函数__main_block_func_0
};

/*__main_block_impl_0： 
是编译器给我们在main函数中定义的block
void (^test)() = ^(){
};
生成的对应的结构体
*/
struct __main_block_impl_0 {
struct __block_impl impl;  　　　　　　　　//__block_impl 变量impl
struct __main_block_desc_0* Desc;　　　　//__main_block_desc_0 指针，指向编译器给我们生成的结构体变量__main_block_desc_0_DATA __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {  //结构体的构造函数
    impl.isa = &_NSConcreteStackBlock;  //说明block是栈blockimpl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;}};



//__main_block_func_0： 编译器根据block代码生成的全局态函数，会被赋值给impl.FuncPtr
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
    }


//__main_block_desc_0: 编译器根据block代码生成的block描述,主要是记录下__main_block_impl_0结构体大小
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; //这里就生成了__main_block_desc_0的变量__main_block_desc_0_DATA


//这里就是main函数了
int main(int argc, char * argv[]) {
    void (*test)() = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA)); //下面单独讲
    ((void (*)(__block_impl *))((__block_impl *)test)->FuncPtr)((__block_impl *)test);　                         //下面单独讲
}
```